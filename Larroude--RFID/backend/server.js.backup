const express = require('express');
const cors = require('cors');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const XLSX = require('xlsx');
const QRCode = require('qrcode');
const JsBarcode = require('jsbarcode');
const { PDFDocument, rgb } = require('pdf-lib');
const archiver = require('archiver');
const sharp = require('sharp');
const axios = require('axios');
const { Label } = require('node-zpl');

const app = express();
const PORT = process.env.PORT || 3002;

// Middleware
app.use(cors());
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ limit: '50mb', extended: true }));
app.use(express.static('public'));

// ConfiguraÃ§Ã£o do multer para upload de arquivos
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = 'uploads';
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir);
    }
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + '-' + file.originalname);
  }
});

const upload = multer({ 
  storage: storage,
  fileFilter: (req, file, cb) => {
    const allowedTypes = ['.xlsx', '.xls', '.csv'];
    const fileExt = path.extname(file.originalname).toLowerCase();
    if (allowedTypes.includes(fileExt)) {
      cb(null, true);
    } else {
      cb(new Error('Apenas arquivos Excel (.xlsx, .xls) ou CSV sÃ£o permitidos'));
    }
  }
});

// Rotas
app.get('/', (req, res) => {
  res.json({ message: 'Servidor LarroudÃ© RFID funcionando!' });
});

// Upload e processamento do arquivo Excel
app.post('/api/upload-excel', upload.single('excel'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'Nenhum arquivo foi enviado' });
    }

    let data;
    const fileExt = path.extname(req.file.path).toLowerCase();
    
    if (fileExt === '.csv') {
      // Ler arquivo CSV
      const csvContent = fs.readFileSync(req.file.path, 'utf8');
      const lines = csvContent.split('\n').filter(line => line.trim());
      
      if (lines.length < 2) {
        return res.status(400).json({ error: 'Arquivo CSV deve ter pelo menos cabeÃ§alho e uma linha de dados' });
      }
      
      const headers = lines[0].split(',').map(h => h.trim());
      data = [];
      
      for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',').map(v => v.trim());
        const row = {};
        headers.forEach((header, index) => {
          row[header] = values[index] || '';
        });
        data.push(row);
      }
    } else {
      // Ler arquivo Excel - processar apenas abas de etiquetas (excluir Sheet1 que Ã© banco de dados)
      const workbook = XLSX.readFile(req.file.path);
      data = [];
      
      // Iterar por todas as abas do arquivo, excluindo Sheet1
      for (const sheetName of workbook.SheetNames) {
        // Pular a aba Sheet1 pois Ã© o banco de dados de referÃªncia
        if (sheetName.toLowerCase() === 'sheet1') {
          continue;
        }
        
        const worksheet = workbook.Sheets[sheetName];
        const sheetData = XLSX.utils.sheet_to_json(worksheet);
        
        if (sheetData.length > 0) {
          // Adicionar dados da aba atual ao array principal
          data = data.concat(sheetData);
        }
      }
    }

    // Validar se o arquivo tem as colunas necessÃ¡rias
    const requiredColumns = ['NAME', 'DESCRIPTION', 'SKU', 'BARCODE', 'REF'];
    const alternativeColumns = ['Variant SKU', 'UPC']; // Formato alternativo
    
    if (data.length === 0) {
      return res.status(400).json({ error: 'Arquivo estÃ¡ vazio' });
    }
    
    // Separar dados por formato
    const standardData = [];
    const alternativeData = [];
    
    data.forEach(row => {
      const hasRequiredColumns = requiredColumns.every(col => col in row);
      const hasAlternativeColumns = alternativeColumns.every(col => col in row);
      
      if (hasRequiredColumns) {
        standardData.push(row);
      } else if (hasAlternativeColumns) {
        // Mapear formato alternativo para padrÃ£o
        const sku = row['Variant SKU'] || '';
        const skuParts = sku.split('-');
        const style = skuParts[1] || '';
        
        alternativeData.push({
          NAME: style,
          DESCRIPTION: `Produto ${style}`,
          SKU: sku,
          BARCODE: row['UPC'] || '',
          REF: sku.split('-')[0] || '',
          QTY: 1
        });
      }
    });
    
    // Combinar todos os dados processados
    data = [...standardData, ...alternativeData];
    
    if (data.length === 0) {
      return res.status(400).json({ 
        error: `Nenhuma aba com colunas vÃ¡lidas encontrada. Esperado: ${requiredColumns.join(', ')} ou ${alternativeColumns.join(', ')}` 
      });
    }
    
    // Processar dados com os novos campos
    data = data.map(row => {
      // Extrair cor e tamanho do SKU (formato: L264-HANA-5.0-WHIT-1120)
      const sku = row.SKU || '';
      const skuParts = sku.split('-');
      const size = skuParts.length >= 3 ? skuParts[2] : '';
      const colorCode = skuParts.length >= 4 ? skuParts[3] : '';
      
      // Mapear cÃ³digos de cor para nomes
      const colorMap = {
        'WHIT': 'WHITE',
        'BLCK': 'BLACK',
        'BRWN': 'BROWN',
        'NAVY': 'NAVY',
        'NUDE': 'NUDE',
        'SILV': 'SILVER',
        'GOLD': 'GOLD',
        'BEIG': 'BEIGE'
      };
      
      const color = colorMap[colorCode] || row.DESCRIPTION?.split(' ').pop() || colorCode || 'N/A';
      
      return {
        STYLE_NAME: row.NAME || '',
        VPM: row.SKU || '',
        COLOR: color,
        SIZE: size || 'N/A',
        BARCODE: row.BARCODE || '',
        DESCRIPTION: row.DESCRIPTION || '',
        REF: row.REF || '',
        QTY: row.QTY || 1
      };
    });

    // Limpar arquivo temporÃ¡rio
    fs.unlinkSync(req.file.path);

    res.json({
      message: 'Arquivo processado com sucesso',
      data: data,
      totalRecords: data.length
    });

  } catch (error) {
    console.error('Erro ao processar arquivo:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// Gerar preview das etiquetas
app.post('/api/generate-preview', async (req, res) => {
  try {
    const { data } = req.body;
    
    if (!data || !Array.isArray(data)) {
      return res.status(400).json({ error: 'Dados invÃ¡lidos' });
    }

    const previews = [];
    
    // Expandir dados baseado no campo QTY para calcular total de etiquetas
    let totalLabels = 0;
    for (const item of data) {
      const qty = parseInt(item.QTY) || 1;
      totalLabels += qty;
    }

    console.log(`Gerando previews para ${totalLabels} etiquetas de ${data.length} itens`);

    // Gerar previews para TODAS as etiquetas (sem limitaÃ§Ã£o)
    for (const item of data) {
      const qty = parseInt(item.QTY) || 1;
      
      for (let i = 0; i < qty; i++) {
        const preview = await generateLabelPreview(item);
        previews.push({
          ...preview,
          itemIndex: data.indexOf(item),
          copyNumber: i + 1,
          totalCopies: qty
        });
      }
    }

    console.log(`Previews gerados: ${previews.length}`);

    res.json({
      previews: previews,
      totalItems: data.length,
      totalLabels: totalLabels,
      previewCount: previews.length
    });

  } catch (error) {
    console.error('Erro ao gerar preview:', error);
    res.status(500).json({ error: 'Erro ao gerar preview' });
  }
});

// Gerar todas as etiquetas
app.post('/api/generate-labels', async (req, res) => {
  try {
    const { data } = req.body;
    
    if (!data || !Array.isArray(data)) {
      return res.status(400).json({ error: 'Dados invÃ¡lidos' });
    }

    const outputDir = 'output';
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir);
    }

    const timestamp = Date.now();
    const zipFileName = `etiquetas-${timestamp}.zip`;
    const zipPath = path.join(outputDir, zipFileName);

    const output = fs.createWriteStream(zipPath);
    const archive = archiver('zip', { zlib: { level: 9 } });

    archive.pipe(output);

    let labelCounter = 1;
    let totalLabelsGenerated = 0;

    for (let i = 0; i < data.length; i++) {
      const item = data[i];
      const qty = parseInt(item.QTY) || 1;
      
      for (let copy = 1; copy <= qty; copy++) {
        try {
          const labelZPL = generateLabelZPL(item);
          const fileName = `etiqueta-${labelCounter}-${item.VPM || 'sem-vpm'}-copia-${copy}.zpl`;
          archive.append(Buffer.from(labelZPL, 'utf8'), { name: fileName });
          labelCounter++;
          totalLabelsGenerated++;
        } catch (error) {
          console.error(`Erro ao gerar etiqueta ${labelCounter}:`, error);
          throw error;
        }
      }
    }

    await archive.finalize();

    output.on('close', () => {
      res.json({
        message: 'Etiquetas ZPL geradas com sucesso',
        downloadUrl: `/api/download/${zipFileName}`,
        totalItems: data.length,
        totalLabels: totalLabelsGenerated
      });
    });

  } catch (error) {
    console.error('Erro ao gerar etiquetas ZPL:', error);
    res.status(500).json({ error: 'Erro ao gerar etiquetas ZPL' });
  }
});

// Download do arquivo ZIP
app.get('/api/download/:filename', (req, res) => {
  const filename = req.params.filename;
  const filePath = path.join('output', filename);
  
  if (fs.existsSync(filePath)) {
    res.download(filePath, (err) => {
      if (err) {
        console.error('Erro no download:', err);
      } else {
        // Limpar arquivo apÃ³s download
        setTimeout(() => {
          if (fs.existsSync(filePath)) {
            fs.unlinkSync(filePath);
          }
        }, 60000); // Remove apÃ³s 1 minuto
      }
    });
  } else {
    res.status(404).json({ error: 'Arquivo nÃ£o encontrado' });
  }
});

// FunÃ§Ã£o para gerar preview da etiqueta
async function generateLabelPreview(item) {
  try {
    // Extrair dados do item
    const styleName = String(item.STYLE_NAME || item.NAME || 'N/A');
    const vpm = String(item.VPM || item.SKU || 'N/A');
    const color = String(item.COLOR || 'N/A');
    const size = String(item.SIZE || 'N/A');
    const barcode = String(item.BARCODE || item.VPM || 'N/A');
    const ref = String(item.REF || 'N/A');
    const qty = String(item.QTY || '1');
    
    // Gerar conteÃºdo conforme novo layout otimizado
    const poLocal = `${ref}\\&Local.SP`; // PO na 1Âª linha e Local.xxx na 2Âª
    const qrLeft = `LA,ESQ-${vpm}-QTY:${qty}`; // QR esquerdo
    const qrTop = `LA,DIR-QR-TOP-${vpm}`; // QR superior direito
    const qrBottom = `LA,DIR-QR-BOTTOM-${vpm}`; // QR inferior direito
    
    // ZPL inline para preview (mesmo que geraÃ§Ã£o final)
    const zplCode = `^XA
^CI28
^LH0,0
^MD30
^PR5
^PW812
^LL406

^FO10,10^GB792,386,2,B,0^FS

^FO20,20^GB50,50,2,B,0^FS
^FO25,25^A0N,16,16^FDðŸ‘ ^FS

^FO720,20^GB70,50,2,B,0^FS
^FO725,25^A0N,12,12^FDPO: ^FS
^FO725,40^A0N,12,12^FD${ref}^FS

^FO20,80^A0N,18,18^FD${styleName}^FS

^FO20,105^A0N,14,14^FDVPM:^FS
^FO70,105^A0N,14,14^FD${vpm}^FS

^FO20,125^A0N,14,14^FDCOLOR:^FS
^FO90,125^A0N,14,14^FD${color}^FS
^FO400,125^A0N,14,14^FDSIZE:^FS
^FO450,125^A0N,14,14^FD${size}^FS

^FO200,160^BY2,2,40^BCN,40,Y,N,N^FD${barcode}^FS

^FO20,220^BQN,2,3^FD${qrLeft}^FS

^FO650,220^BQN,2,3^FD${qrTop}^FS

^FO720,370^A0N,12,12^FD${ref}^FS
^XZ`
    
    console.log('ZPL gerado para preview:', zplCode);
    
    try {
      // Usar API do Labelary para converter ZPL para imagem em tamanho real
      // Usando 12dpmm (300 DPI) para melhor qualidade e tamanho real 4x6 polegadas
      const labelaryResponse = await axios.post(
        'http://api.labelary.com/v1/printers/12dpmm/labels/4x6/0/',
        zplCode,
        {
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'Accept': 'image/png'
          },
          responseType: 'arraybuffer'
        }
      );
      
      // Converter para base64 mantendo o tamanho real
      const base64Image = Buffer.from(labelaryResponse.data).toString('base64');
      
      return {
        id: item.VPM || item.SKU || Math.random().toString(36).substr(2, 9),
        styleName: styleName,
        vpm: vpm,
        color: color,
        size: size,
        barcode: barcode,
        ref: ref,
        qty: item.QTY || 1,
        preview: `data:image/png;base64,${base64Image}`
      };
      
    } catch (labelaryError) {
      console.error('Erro ao converter ZPL via Labelary:', labelaryError.message);
      
      // Fallback: usar SVG em tamanho real da etiqueta (4x6 polegadas = 384x576 pixels a 96 DPI)
      const fallbackSvg = `
        <svg width="384" height="576" xmlns="http://www.w3.org/2000/svg">
          <rect width="384" height="576" fill="white" stroke="black" stroke-width="3"/>
          
          <!-- Ãcone do sapato -->
          <rect x="20" y="20" width="40" height="40" fill="none" stroke="black" stroke-width="2"/>
          <text x="30" y="45" font-family="Arial" font-size="20">ðŸ‘ </text>
          
          <!-- Caixa PO -->
          <rect x="280" y="20" width="80" height="50" fill="none" stroke="black" stroke-width="2"/>
          <text x="290" y="40" font-family="Arial" font-size="12">PO:</text>
          <text x="290" y="55" font-family="Arial" font-size="12">${ref}</text>
          
          <!-- InformaÃ§Ãµes principais -->
          <text x="20" y="100" font-family="Arial" font-size="18" font-weight="bold">${styleName}</text>
          <text x="20" y="130" font-family="Arial" font-size="14">VPM: ${vpm}</text>
          <text x="20" y="155" font-family="Arial" font-size="14">COLOR: ${color}</text>
          <text x="200" y="155" font-family="Arial" font-size="14">SIZE: ${size}</text>
          
          <!-- CÃ³digo de barras (simulado) -->
          <rect x="50" y="180" width="280" height="40" fill="none" stroke="black" stroke-width="1"/>
          <text x="60" y="205" font-family="monospace" font-size="12">${barcode}</text>
          
          <!-- QR Codes (simulados) -->
          <rect x="30" y="450" width="80" height="80" fill="none" stroke="black" stroke-width="2"/>
          <text x="35" y="470" font-family="Arial" font-size="8">QR Left</text>
          <text x="35" y="485" font-family="Arial" font-size="6">${qrLeft.substring(0, 15)}...</text>
          
          <rect x="270" y="450" width="80" height="80" fill="none" stroke="black" stroke-width="2"/>
          <text x="275" y="470" font-family="Arial" font-size="8">QR Right</text>
          <text x="275" y="485" font-family="Arial" font-size="6">larroude.com</text>
          
          <!-- InformaÃ§Ã£o local -->
          <text x="300" y="550" font-family="Arial" font-size="12">BR001</text>
        </svg>
      `;
      
      const pngBuffer = await sharp(Buffer.from(fallbackSvg))
        .png()
        .toBuffer();
      
      const base64Image = pngBuffer.toString('base64');
      
      return {
        id: item.VPM || item.SKU || Math.random().toString(36).substr(2, 9),
        styleName: styleName,
        vpm: vpm,
        color: color,
        size: size,
        barcode: barcode,
        ref: ref,
        qty: item.QTY || 1,
        preview: `data:image/png;base64,${base64Image}`
      };
    }
    
  } catch (error) {
    console.error('Erro ao gerar preview:', error);
    throw error;
  }
}

// FunÃ§Ã£o para gerar ZPL da etiqueta usando sistema de templates ^FN
function generateLabelZPL(item) {
  // Gerar cÃ³digo ZPL inline (sem templates externos)
  // DimensÃµes: 4.0" x 2.0" (203 DPI) conforme especificaÃ§Ã£o
  
  const styleName = String(item.STYLE_NAME || item.NAME || 'N/A');
  const vpm = String(item.VPM || item.SKU || 'N/A');
  const color = String(item.COLOR || 'N/A');
  const size = String(item.SIZE || 'N/A');
  const barcode = String(item.BARCODE || item.VPM || 'N/A');
  const ref = String(item.REF || 'N/A');
  const qty = String(item.QTY || '1');
  
  // Gerar conteÃºdo conforme layout otimizado
  const poLocal = `${ref}\&Local.SP`; // PO na 1Âª linha e Local.xxx na 2Âª
  const qrLeft = `LA,ESQ-${vpm}-QTY:${qty}`; // QR esquerdo
  const qrTop = `LA,DIR-QR-TOP-${vpm}`; // QR superior direito
  const qrBottom = `LA,DIR-QR-BOTTOM-${vpm}`; // QR inferior direito
  
  // ZPL inline baseado no template LAYOUT_LABEL.ZPL
  const zplCode = `^XA
^CI28
^LH0,0
^MD30
^PR5
^PW812
^LL406

^FO10,10^GB792,386,2,B,0^FS

^FO20,20^GB50,50,2,B,0^FS
^FO25,25^A0N,16,16^FDðŸ‘ ^FS

^FO720,20^GB70,50,2,B,0^FS
^FO725,25^A0N,12,12^FDPO: ^FS
^FO725,40^A0N,12,12^FD${ref}^FS

^FO20,80^A0N,18,18^FD${styleName}^FS

^FO20,105^A0N,14,14^FDVPM:^FS
^FO70,105^A0N,14,14^FD${vpm}^FS

^FO20,125^A0N,14,14^FDCOLOR:^FS
^FO90,125^A0N,14,14^FD${color}^FS
^FO400,125^A0N,14,14^FDSIZE:^FS
^FO450,125^A0N,14,14^FD${size}^FS

^FO200,160^BY2,2,40^BCN,40,Y,N,N^FD${barcode}^FS

^FO20,220^BQN,2,3^FD${qrLeft}^FS

^FO650,220^BQN,2,3^FD${qrTop}^FS

^FO720,370^A0N,12,12^FD${ref}^FS
^XZ`;
  
  return zplCode;
}

async function generateLabelPDF(item) {
  const pdfDoc = await PDFDocument.create();
  // Tamanho baseado na proporÃ§Ã£o da imagem (aproximadamente 4:1)
  const page = pdfDoc.addPage([566, 142]); // 10cm x 2.5cm em pontos (72 DPI)
  
  const { width, height } = page.getSize();
  
  // Borda externa
  page.drawRectangle({
    x: 5,
    y: 5,
    width: width - 10,
    height: height - 10,
    borderColor: rgb(0, 0, 0),
    borderWidth: 1
  });
  
  // Ãrea principal da etiqueta
  page.drawRectangle({
    x: 10,
    y: 10,
    width: width - 120, // Deixa espaÃ§o para QR codes laterais
    height: height - 20,
    borderColor: rgb(0, 0, 0),
    borderWidth: 1
  });
  
  // QR Code removido - deixando espaÃ§o em branco conforme solicitado
  
  // InformaÃ§Ãµes do produto
  page.drawText(`NAME: ${String(item.STYLE_NAME || 'N/A')}`, {
    x: 65,
    y: height - 25,
    size: 10,
    color: rgb(0, 0, 0)
  });
  
  page.drawText(`SKU: ${String(item.VPM || 'N/A')}`, {
    x: 65,
    y: height - 40,
    size: 10,
    color: rgb(0, 0, 0)
  });
  
  page.drawText(`COLOR: ${String(item.COLOR || 'N/A')}`, {
    x: 65,
    y: height - 55,
    size: 10,
    color: rgb(0, 0, 0)
  });
  
  page.drawText(`SIZE: ${String(item.SIZE || 'N/A')}`, {
    x: 65,
    y: height - 70,
    size: 10,
    color: rgb(0, 0, 0)
  });
  
  // CÃ³digo de barras
  const barcodeWidth = 200;
  const barcodeHeight = 25;
  const barcodeX = 65;
  const barcodeY = 25;
  
  // Simular cÃ³digo de barras CODE128 usando BARCODE
  for (let i = 0; i < 50; i++) {
    const barWidth = Math.random() > 0.5 ? 2 : 1;
    const x = barcodeX + (i * 4);
    if (x < barcodeX + barcodeWidth) {
      page.drawRectangle({
        x: x,
        y: barcodeY,
        width: barWidth,
        height: barcodeHeight,
        color: rgb(0, 0, 0)
      });
    }
  }
  
  // Texto do cÃ³digo de barras usando BARCODE
  page.drawText(String(item.BARCODE || item.VPM || 'N/A'), {
    x: barcodeX + 50,
    y: barcodeY - 15,
    size: 8,
    color: rgb(0, 0, 0)
  });
  
  // QR Code grande removido - deixando espaÃ§o em branco conforme solicitado
  
  // CÃ³digo REF no canto inferior direito
  page.drawRectangle({
    x: width - 105,
    y: 15,
    width: 90,
    height: 35,
    borderColor: rgb(0, 0, 0),
    borderWidth: 1
  });
  
  page.drawText('REF:', {
    x: width - 95,
    y: 40,
    size: 10,
    color: rgb(0, 0, 0)
  });
  
  page.drawText(String(item.REF || 'N/A'), {
    x: width - 95,
    y: 25,
    size: 8,
    color: rgb(0, 0, 0)
  });
  
  // QR Code pequeno removido - deixando espaÃ§o em branco conforme solicitado
  
  return await pdfDoc.save();
}

// Tratamento de erros
app.use((error, req, res, next) => {
  console.error('Erro:', error);
  res.status(500).json({ error: 'Erro interno do servidor' });
});

app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});

module.exports = app;
